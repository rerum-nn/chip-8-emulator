# Chip-8 Emulator
Эмулятор работы программ, написанных на CHIP-8

# Мотивация
Курс "Архитектура компьютера" направлен на знакомство с ассемблером и внутренним устройством электронной вычислительной техники. Эмуляция работы CHIP-8 была выбрана как попытка воссоздания процессов, происходящих внутри компьютера, но в виртуальной среде.

# TODO
Планируется использовать отдельные классы для памяти и для обработчика команд (ядро). Ближайший ориентир и цель — создать "backend" для эмулятора, способы вывода — задача второстепенная и сейчас не является такой актуальной. 
Вопросы и проблемы на данном этапе: 
- Как реализовать обработчик инструкций? Использовать паттерн "Комманда" и хранить ссылки на соответствующии функторы, отвечающие за конкретные операции (можно эффективно использовать насследование для уменьшения кода), или загромоздить весь код switch case'ами? Так как CHIP-8 подразумевает очень медленную обработку команд (сравнительно с современным железом), то задача в вычислительной скорости не стоит, можно позаботиться о читаемости кода и его будущей модификации (CHIP-16/Super CHIP). Следующая проблема возникает после предыдущего предложения:
- Как наиболее эффективно и правильно реализовать пульсатор для синхроннизации выполнения комманд? По этому вопросу необходимо провести отдельное исследование. К тому же, кажется, что пульсатор будет несложно внедрить в код после реализации основного блока инструкций.
- Бывают ситуации, когда в память необходимо записывать вплоть до 32 байт, тогда необходимо придумать более эффективный способ делать это из процессора, не обращаясь к промежуточным методам фукнции (тем более для разного количества байт придется плодить большую кучу функций, если придерживаться того способа реализации, который был выбран), поэтому нужно либо создать универсальные метода записи и чтения, передавать им указатель на данные и количество считываемых байт (плюс метода -- некоторые инструкции требуют последовательной записи, либо чтения в регистры, следовательно, можно просто передавать указатель на буфер регистров), либо делать процессор дружественной функцией и дать ему прямой доступ к памяти. Мы склоняемся более к первому варианту решения проблемы, так как в программах могут быть ситуации, когда она пытается обратиться к запрещенной памяти (такой например является 0x000-0x200), тогда память должна обрабатывать такие запросы и что-то с ними делать (аварийно завершать программу/возвращать ноль при чтении памяти, ничего не делать при записи).

# Обязанности на текущий момент
- Rerum_nn: реализация обработчика инструкций, основного цикла работы ядра (все что связано с execute)
- 0ficus: реализация логического и математического блока (все что связано с обработкой)
- Zzifi: реализация класса памяти, реализация блока инструкций, связанных с перемещением по памяти и с ее взаимодействием

# Roadmap
- Базовая логика работы модели ядра и памяти
- Ввод с клавиатуры
- Вывод на экран
- Загрузка программы из файла

# Тестирование
Необходимо проводить промежуточное тестирование работы кода, чтобы быть уверенным в его работе и быстром поиске места возникновения ошибок. Для тестирования было решено использовать фреймворк Catch2. Тесты должны быть написаны как программистом-разработчиком, ответственным за определенную часть кода, так и с помощью других участников проекта, путем предоставления интерфейса написанной части кода (насколько это будет пользоваться популярностью в команде пока что рано судить :) ).

# Источники
- [Общая информация по CHIP-8](https://github.com/mattmikolay/chip-8/wiki/Mastering-CHIP%E2%80%908)
- [Больше информации о технической части и описание instruction set](http://devernay.free.fr/hacks/chip8/C8TECH10.HTM)
- [One more спецификация](https://tonisagrista.com/blog/2021/chip8-spec/)
- [Wikipedia](https://en.wikipedia.org/wiki/CHIP-8)
