# Chip-8 Emulator
Эмулятор работы программ, написанных на CHIP-8

# Мотивация
Курс "Архитектура компьютера" направлен на знакомство с ассемблером и внутренним устройством электронной вычислительной техники. Эмуляция работы CHIP-8 была выбрана как попытка воссоздания процессов, происходящих внутри компьютера, но в виртуальной среде.

# TODO
Ближайший ориентир и цель — создать "backend" для эмулятора, способы вывода — задача второстепенная и сейчас не является такой актуальной. Так как мы живем в ООП мире плюсов, то и для каждой сущности будет разрабатываться отдельный класс для работы с ней.
Вопросы и проблемы на данном этапе: 
- Как организовать код, связанный с блоком инструкций? Не хочется загромождать основной класс ядра большим количеством функций, поэтому всю логику, связанную с выполнением инструкций, нужно поместить в отдельный класс (также есть мысли о возможности разделить обработку инструкций и непосредственно их выполнение в разные классы).
- Как реализовать обработчик инструкций? Использовать паттерн "Комманда" и хранить ссылки на соответствующии функторы, отвечающие за конкретные операции (можно эффективно использовать насследование для уменьшения кода), или загромоздить весь код switch case'ами? При выборе одного из вариантов необходимо учитывать, что все опкоды представляются в виде 2 байт, можно выбрать что то среднее между этими двумя способами. Так как CHIP-8 подразумевает медленную обработку команд (сравнительно с современным железом, хотя на хабре говорят, что даже так можно накосячить с эффективностью выполнения), то задача в вычислительной скорости не стоит, можно позаботиться о читаемости кода и его будущей модификации (Super CHIP). Следующая проблема возникает после предыдущего предложения:
- Как наиболее эффективно и правильно реализовать пульсатор для синхроннизации выполнения комманд? По этому вопросу необходимо провести отдельное исследование. К тому же, кажется, что пульсатор будет несложно внедрить в код после реализации основного блока инструкций.

В целом, текущий этап можно описать так: "Как бы ухитриться сделать сразу хороший интерфейс для всех компонент, чтобы потом пришлось переписывать меньше кода". 

# Обязанности на текущий момент
- Rerum_nn: реализация обработчика инструкций, основного цикла работы ядра (все что связано с execute)
- 0ficus: реализация логического и математического блока (все что связано с обработкой)
- Zzifi: реализация класса памяти, реализация блока инструкций, связанных с перемещением по памяти и с ее взаимодействием (все что связано с памятью)

# Roadmap
- Базовая логика работы модели ядра и памяти без инструкций, связанных с отрисовкой 
- Ввод с клавиатуры
- Вывод на экран
- Загрузка программы из файла

# Тестирование
Необходимо проводить промежуточное тестирование работы кода, чтобы быть уверенным в его работе и для быстрого поиска мест возникновения ошибок. Для тестирования было решено использовать фреймворк Catch2. Тесты должны быть написаны как программистом-разработчиком, ответственным за определенную часть кода, так и с помощью других участников проекта, путем предоставления интерфейса написанной части кода (насколько это будет пользоваться популярностью в команде пока что рано судить :) ).

# На будущее
Адресса 0xF00-0xFFF используются для видеопамяти, нужно реализовать метод класса памяти, который будет возвращать именно этот промежуток буфера в объект отрисовки изображения. Понадобится для того, кто будет писать блок инструкций, связанный с отрисовкой.

# Источники
- [Общая информация по CHIP-8](https://github.com/mattmikolay/chip-8/wiki/Mastering-CHIP%E2%80%908)
- [Больше информации о технической части и описание instruction set](http://devernay.free.fr/hacks/chip8/C8TECH10.HTM)
- [One more спецификация](https://tonisagrista.com/blog/2021/chip8-spec/)
- [Wikipedia](https://en.wikipedia.org/wiki/CHIP-8)
